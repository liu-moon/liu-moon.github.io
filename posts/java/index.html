<!DOCTYPE html>
<html lang='en' ><meta charset="utf-8">
<meta name="viewport" content="width=device-width">


<title>Java | Quy&#39;s blog</title>
<link rel="stylesheet" href="https://liu-moon.github.io/css/eureka.min.css">
<script defer src="https://liu-moon.github.io/js/eureka.min.js"></script>

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload"
  href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Noto+Serif+SC:wght@400;600;700&display=swap"
  as="style" onload="this.onload=null;this.rel='stylesheet'">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/styles/solarized-light.min.css%25!%28EXTRA%20string=solarized-light%29"
   media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/highlight.min.js"
   crossorigin></script>

  <script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/languages/dart.min.js"
     crossorigin></script>

<script defer src="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/js/all.min.js"
   integrity="sha256-uNYoXefWRqv&#43;PsIF/OflNmwtKM4lStn9yrz2gVl6ymo="  crossorigin></script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
   integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3&#43;Aro6EYUG4&#43;cU&#43;KJWu/X"  media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" 
  integrity="sha384-g7c&#43;Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI&#43;sEnkvrMWph2EDg4"  crossorigin></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
   integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC&#43;Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa"  crossorigin></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true }
      ],
    });
  });
</script>


<link rel="icon" type="image/png" sizes="32x32" href="https://liu-moon.github.io/images/icon_hu64421c6c7700f606f0ad45d807017b09_5843_32x32_fill_box_center_2.png">
<link rel="apple-touch-icon" sizes="180x180" href="https://liu-moon.github.io/images/icon_hu64421c6c7700f606f0ad45d807017b09_5843_180x180_fill_box_center_2.png">

<meta name="description"
  content="Java Learing">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
      "@type": "ListItem",
      "position": 1 ,
      "name":"Posts",
      "item":"https://liu-moon.github.io/posts/"},{
      "@type": "ListItem",
      "position": 2 ,
      "name":"Java",
      "item":"https://liu-moon.github.io/posts/java/"}]
}
</script>



<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://liu-moon.github.io/posts/java/"
    },
    "headline": "Java | Quy\u0027s blog","datePublished": "2021-02-17T09:12:16+08:00",
    "dateModified": "2021-02-17T09:12:16+08:00",
    "wordCount":  2860 ,
    "publisher": {
        "@type": "Person",
        "name": "C. Wang",
        "logo": {
            "@type": "ImageObject",
            "url": "https://liu-moon.github.io/images/icon.png"
        }
        },
    "description": "\u003ch1 id=\u0022java-learing\u0022\u003eJava Learing\u003c\/h1\u003e"
}
</script><meta property="og:title" content="Java | Quy&#39;s blog" />
<meta property="og:type" content="article" />


<meta property="og:image" content="https://liu-moon.github.io/images/icon.png">


<meta property="og:url" content="https://liu-moon.github.io/posts/java/" />




<meta property="og:description" content="Java Learing" />




<meta property="og:locale" content="en" />




<meta property="og:site_name" content="Quy&#39;s blog" />






<meta property="article:published_time" content="2021-02-17T09:12:16&#43;08:00" />


<meta property="article:modified_time" content="2021-02-17T09:12:16&#43;08:00" />



<meta property="article:section" content="posts" />




<body class="flex flex-col min-h-screen">
  <header class="fixed flex items-center w-full min-h-16 pl-scrollbar z-50 bg-secondary-bg shadow-sm">
    <div class="w-full max-w-screen-xl mx-auto"><script>
    let storageColorScheme = localStorage.getItem("lightDarkMode")
    if (((storageColorScheme == 'Auto' || storageColorScheme == null) && window.matchMedia("(prefers-color-scheme: dark)").matches) || storageColorScheme == "Dark") {
        document.getElementsByTagName('html')[0].classList.add('dark')
    }
</script>
<nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0">
    <a href="/" class="mr-6 text-primary-text text-xl font-bold">Quy&#39;s blog</a>
    <button id="navbar-btn" class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
        <i class="fas fa-bars"></i>
    </button>

    <div id="target"
        class="hidden block md:flex md:flex-grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20">
        <div class="md:flex md:h-16 text-sm md:flex-grow pb-4 md:pb-0 border-b md:border-b-0">
            <a href="/#about" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  mr-4">About</a>
            <a href="/posts/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  selected-menu-item  mr-4">Posts</a>
            <a href="/docs/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  mr-4">Docs</a>
        </div>

        <div class="flex">
            <div class="relative pt-4 md:pt-0">
                <div class="cursor-pointer hover:text-eureka" id="lightDarkMode">
                    <i class="fas fa-adjust"></i>
                </div>
                <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id="is-open">
                </div>
                <div class="absolute flex flex-col left-0 md:left-auto right-auto md:right-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40"
                    id='lightDarkOptions'>
                    <span class="px-4 py-1 hover:text-eureka">Light</span>
                    <span class="px-4 py-1 hover:text-eureka">Dark</span>
                    <span class="px-4 py-1 hover:text-eureka">Auto</span>
                </div>
            </div>
        </div>
    </div>

    <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id="is-open-mobile">
    </div>

</nav>
<script>
    let element = document.getElementById('lightDarkMode')
    if (storageColorScheme == null || storageColorScheme == 'Auto') {
        document.addEventListener('DOMContentLoaded', () => {
            switchMode('Auto')
        })
    } else if (storageColorScheme == "Light") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'sun')
        element.firstElementChild.classList.add('fa-sun')
    } else if (storageColorScheme == "Dark") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'moon')
        element.firstElementChild.classList.add('fa-moon')
    }
    
    document.addEventListener('DOMContentLoaded', () => {
        getcolorscheme();
        switchBurger();
    });
</script></div>
  </header>
  <main class="flex-grow pt-16">
    <div class="pl-scrollbar">
      <div class="w-full max-w-screen-xl lg:px-4 xl:px-8 mx-auto">


<div class="grid grid-cols-2 lg:grid-cols-8 gap-4 lg:pt-12">
    <div
        class="col-span-2  lg:col-span-6 bg-secondary-bg rounded px-6 py-8">
        <h1 class="font-bold text-3xl text-primary-text">Java</h1>
        <div class="flex flex-wrap flex-row items-center mt-2 text-tertiary-text">
    <div class="mr-6 my-2">
        <i class="fas fa-calendar mr-1"></i>
        <span>2021-02-17</span>
    </div>
    <div class="mr-6 my-2">
        <i class="fas fa-clock mr-1"></i>
        <span>14 min read</span>
    </div>
    
    

    
</div>
        
        
        

        <div class="content">
            <h1 id="java-learing">Java Learing</h1>
<h2 id="idea常用快捷键">idea常用快捷键</h2>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl+Shift+/</td>
<td>多行注释</td>
</tr>
<tr>
<td>Alt+Enter</td>
<td>导包</td>
</tr>
<tr>
<td>Ctrl+Alt+L</td>
<td>代码格式化</td>
</tr>
<tr>
<td>Shift+Tab</td>
<td>取消缩进</td>
</tr>
<tr>
<td>Alt + insert</td>
<td>快速生成构造方法和getXXX(),setXXX()方法</td>
</tr>
<tr>
<td>Alt + enter</td>
<td>重写方法</td>
</tr>
</tbody>
</table>
<h2 id="方法重载overload">方法重载(Overload)</h2>
<p>在同一个类中的多个方法，他们的方法名相同，参数列表不同，这样的情况，称为方法重载。重载与返回值类型无关</p>
<h2 id="scanner的基本使用">Scanner的基本使用</h2>
<h3 id="scanner的步骤">Scanner的步骤</h3>
<p>扫描器。即可以通过Scanner类扫描用户在控制台录入的数据键盘录入数据的步骤</p>
<ol>
<li>导包</li>
<li>创建键盘录入对象</li>
<li>接收数据</li>
</ol>
<pre><code class="language-java">//1.导包
import java.util.Scanner;

public class ScannerDemo {
    public static void main(String[] args) {
        
        //2.创建键盘录入对象
        Scanner sc = new Scanner(System.in);

        System.out.println(&quot;请输入一个整数&quot;);
        
        //3.接收数据
        int i = sc.nextInt();

        System.out.println(&quot;i: &quot; + i);
    }
}
</code></pre>
<h2 id="break标号">break标号</h2>
<ul>
<li>需求：程序猿同学受邀加入A公司，现按班级查找程序猿同学。现有3个班级，每班10个同学，假设第2个班级的第5位同学名叫程序猿，找到该同学后则停止查找。</li>
</ul>
<pre><code class="language-java">public class BreakDemo2 {
    public static void main(String[] args) {
        /*
            需求: 程序猿同学受邀加入A公司，现按班级查找程序猿同学。
            已知:
                现有3个班级，每班10个同学，
                假设第2个班级的第5位同学名叫程序猿，找到该同学后则停止查找。
        */
        //1. 通过for循环, 获取到每一个班级.
        label_class:for (int i = 1; i &lt; 4; i++) {       //需求: 外循环, 是用来获取到每一个班级的.
            //2. 在班级循环中, 再次通过for循环获取到每一个学生的信息.
            for (int j = 1; j &lt; 11; j++) {  //需求: 内循环, 是用来获取每一个学生的.
                //3. 打印当前学生的信息.
                System.out.println(&quot;正在查找第&quot;+ i +&quot;个班级的第&quot;+ j +&quot;个学生&quot;);
                //4. 判断当前学生是否是 程序猿同学(第2个班级的第5位同学)
                if(i == 2 &amp;&amp; j == 5) {
                    //5. 如果是, 则结束整个循环.
                    System.out.println(&quot;哈哈, 找到程序猿同学了, 整个循环结束&quot;);
                    break label_class;          //结束指定的循环
                }

            }
            //换行
            System.out.println();
        }
    }
}
</code></pre>
<ul>
<li>
<p>需求: 1024程序员节，小黑带你发橙子</p>
<p>已知条件:</p>
<ol>
<li>假设有3个班级，每个班级有35个同学，现在要将100个橙子分别发放给每位同学，每人只能拿一个。</li>
<li>如果该同学已经有了橙子，则不再发给该同学；如果橙子发完了，则发放活动终止。</li>
<li>假设编号为5的倍数的同学都已经有了橙子.</li>
</ol>
</li>
</ul>
<pre><code class="language-java">public class orange {
    public static void main(String[] args) {
        int count = 0;
        sendorange:
        for (int i = 1; i &lt; 4; i++) {
            for (int j = 0; j &lt; 36; j++) {
                if (j % 5 == 0) {
                    continue;
                }
                System.out.println(&quot;正在给第&quot; + i + &quot;个班级的第&quot; + j + &quot;个同学发放橙子&quot;);
                count++;
                if (100 - count == 0) {
                    break sendorange;
                }
            }
        }
        System.out.println(&quot;共发放了&quot; + count + &quot;个橙子&quot;);
    }
}
</code></pre>
<h2 id="random类">Random类</h2>
<h3 id="random类的使用">Random类的使用</h3>
<pre><code class="language-java">import java.util.Random;

public class random {
    public static void main(String[] args) {
        Random r = new Random();
        for (int x = 0; x &lt;=10 ; x++) {
            int number = r.nextInt(10);
            //获取0-9内的随机数
            System.out.println(&quot;number&quot; +number);
        }
    }
}
</code></pre>
<h3 id="案例-猜数字的小游戏">案例: 猜数字的小游戏</h3>
<ul>
<li>系统产生一个1-100之间的随机数，请猜出这个数是多少。</li>
</ul>
<pre><code class="language-java">import java.util.Random;
import java.util.Scanner;

public class guessnum {
    public static void main(String[] args) {
        Random r = new Random();
        int number= r.nextInt(100)+1;
        //System.out.println(&quot;number:&quot;+number);
        Scanner sc = new Scanner(System.in);
        System.out.println(&quot;请输入一个1-100内的整数&quot;);
        for(;;) {
            int i = sc.nextInt();
            if (i&gt;number ) {
                System.out.println(&quot;你猜的数据大了&quot;);
            }else if (i&lt;number){
                System.out.println(&quot;你猜的数据小了&quot;);
            }else{
                System.out.println(&quot;恭喜你猜对了&quot;);
                break;
            }
        }
    }
}
</code></pre>
<h2 id="抽象">抽象</h2>
<h3 id="手机类">手机类</h3>
<pre><code class="language-java">/*
定义一个手机类
*/
public class phone {
    //成员变量：定义在类中，方法外的变量
    //品牌
    String brand;
    //型号
    String model;
    //名称
    String name;

    //成员方法：先不写static修饰符
    //打电话
    public void call(String name){
        System.out.println(&quot;给&quot;+name+&quot;打电话&quot;);
    }
    //发短信
    public void sendMessage() {
        System.out.println(&quot;发短信&quot;);
    }
    //玩游戏
    public void playGame() {
        System.out.println(&quot;玩游戏&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class testphone {
    public static void main(String[] args) {
        //1. 创建对象
        phone p = new phone();

        //2. 调用成员变量，并打印
        //给成员变量赋值
        p.brand = &quot;苹果&quot;;
        p.model = &quot;X&quot;;
        p.name = &quot;程序猿&quot;;

        //打印成员变量的值
        System.out.println(p.brand);
        System.out.println(p.model);
        System.out.println(p.name);

        //3. 调用成员方法。
        p.call(&quot;蓁蓁&quot;);
        p.sendMessage();
        p.playGame();
    }
}
</code></pre>
<h2 id="privatethis">private&amp;this</h2>
<pre><code class="language-java">/*
    定义一个学生类, 用来演示this关键字
 */
public class Student {
    //成员变量
    private int age = 20;

    //设置年龄
    public void setAge(int age) { // age = 50;
        this.age = age;
    }

    //获取年龄
    public int getAge() {
        return age;
    }

    //为了让你更好的理解this的作用, 先做一个测试题.
    public void show() {
        //局部变量
        int age = 10;

        System.out.println(age);   //10
        System.out.println(this.age);   //20 ?
    }
}
</code></pre>
<pre><code class="language-java">public class TestStudent {
    public static void main(String[] args) {
        //需求1: 调用show()方法

        Student stu = new Student();
        stu.show();
        System.out.println(&quot;--------------&quot;);


        //需求2: 按照格式, 优化setAge()中的参数名, 并调用.
        //设置年龄
        stu.setAge(50);
        //获取年龄
        System.out.println(stu.getAge());
    }
}
</code></pre>
<h2 id="构造方法">构造方法</h2>
<ul>
<li>
<p>作用: 用来初始化对象的.</p>
</li>
<li>
<p>格式:</p>
<p>​      修饰符 构造方法名(参数列表) {</p>
<p>​        //方法体</p>
<p>​      }</p>
</li>
<li>
<p>要求:</p>
<ul>
<li>构造方法名必须和类名相同(包括大小写)</li>
</ul>
</li>
<li>
<p>构造方法没有返回值(但是里边可以写return)</p>
</li>
<li>
<p>构造方法没有返回值类型(连void都不能写)</p>
</li>
<li>
<p>注意:</p>
<ul>
<li>若未提供任何构造方法，系统会给出默认无参构造</li>
</ul>
</li>
<li>
<p>若已提供任何构造方法，系统不再提供无参构造</p>
<ul>
<li>构造方法可以重载</li>
</ul>
</li>
</ul>
<pre><code class="language-java">/*
    定义一个学生类
 */
public class Student {
    //构造方法
    //无参构造
    public Student() { }

    //带参构造
    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    //成员变量
    private String name;
    private int age;

    //设置姓名
    public void setName(String name) {
        this.name = name;
    }
    //获取姓名
    public String getName() {
        return name;
    }

    //设置年龄
    public void setAge(int age) {
        this.age = age;
    }

    //获取年龄
    public int getAge() {
        return age;
    }
}
</code></pre>
<pre><code class="language-java">public class TestStudent {
    public static void main(String[] args) {
        //需求: 定义一个姓名叫: 张三, 年龄为: 23 的学生
        //格式一: 通过无参构造实现.
        Student stu = new Student();
        stu.setName(&quot;张三&quot;);
        stu.setAge(23);

        System.out.println(stu.getName());
        System.out.println(stu.getAge());
        System.out.println(&quot;--------------------&quot;);

        //格式二: 通过构造方法实现快速初始化.
        Student stu2 = new Student(&quot;李四&quot;, 24);
        System.out.println(stu2.getName());
        System.out.println(stu2.getAge());

    }
}
</code></pre>
<h2 id="javabean类">JavaBean类</h2>
<pre><code class="language-java">/*
    定义一个标准的JavaBean类
 */
public class Student {
    //成员变量, 全部用private修饰.
    //姓名
    private String name;
    //年龄
    private int age;

    //构造方法, 无参构造, 全参构造
    public Student() {}

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    //公共的访问方式: getXXX(), setXXX()
    //设置姓名
    public void setName(String name) {
        this.name = name;
    }
    //获取姓名
    public String getName() {
        return name;
    }
    //设置年龄
    public void setAge(int age) {
        this.age = age;
    }

    //获取年龄
    public int getAge() {
        return age;
    }
}
</code></pre>
<pre><code class="language-java">public class TestStudent {
    public static void main(String[] args) {
        //需求: 通过空参创建对象.
        Student stu1 = new Student();
        stu1.setName(&quot;张无忌&quot;);
        stu1.setAge(23);
        System.out.println(stu1.getName());
        System.out.println(stu1.getAge());
        System.out.println(&quot;-------------------&quot;);

        //需求: 通过全参创建对象.
        Student stu2 = new Student(&quot;韦小宝&quot;, 40);
        System.out.println(stu2.getName());
        System.out.println(stu2.getAge());
    }
}
</code></pre>
<h2 id="继承">继承</h2>
<p>Java中, 子类只能继承父类的非私有成员(成员变量, 成员方法)</p>
<pre><code class="language-java">//定义一个父类: Parent
public class Parent {
    //成员变量
    private String name;
    private int age;

    //快捷键: alt + insert, 快速生成构造方法和getXXX(),setXXX()方法.
    //构造方法
    public Parent() {
    }

    public Parent(String name, int age) {
        this.name = name;
        this.age = age;
    }
    //getXXX()和setXXX()方法

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
</code></pre>
<pre><code class="language-java">/*
    Child: 子类, 派生类
    Parent: 父类, 基类, 超类
 */
public class Child extends Parent {
}
</code></pre>
<pre><code class="language-java">//测试类
public class Test {
    //main函数是程序的主入口, 所有的代码都是从这里开始执行的.
    public static void main(String[] args) {
        //创建Child类的对象
        Child c = new Child();

        //给对象c的姓名设置为: 张三.
        c.setName(&quot;张三&quot;);
        //c.name = &quot;李四&quot;;

        //打印姓名的值
        System.out.println(c.getName());

        /*
            Java中, 子类只能继承父类的非私有成员(成员变量, 成员方法)
         */
    }
}
</code></pre>
<h3 id="super">super</h3>
<pre><code class="language-java">//测试类
public class Test {
    public static void main(String[] args) {
        /*
            使用变量遵循就近原则.
                先在局部位置找, 有就使用.
                没有就去本类的成员位置找, 有就使用.
                没有就去父类的成员位置找, 有就使用, 没有就报错.

             如果局部变量, 本类的成员变量, 父类的成员变量重名了, 如何解决?
                直接写变量名:     局部变量.
                this.成员变量名:  本类的成员变量
                super.成员变量名: 父类的成员变量
         */
        Zi zi = new Zi();
        zi.show();
    }
}
</code></pre>
<pre><code class="language-java">//父类
public class Fu {
    int num = 30;
}
</code></pre>
<pre><code class="language-java">//子类
public class Zi extends Fu {
    int num = 20;

    public void show() {
        int num = 10;

        System.out.println(num);         //10
        System.out.println(this.num);    //20
        System.out.println(super.num);   //30
    }
}
</code></pre>
<h3 id="继承关系中成员方法的使用">继承关系中成员方法的使用</h3>
<pre><code class="language-java">/*
    需求:
        定义武功类Martial:
            练习内功: internalStrength()
            练习招式: stroke()
	    定义九阴真经类NineYin，继承Martial类
	        练习内功: internalStrength()
            练习招式: stroke()
        九阴真经的修炼，不仅要练习基本内功，还要能够以柔克刚，需要扩展父类方法；
        简单的招式已经不足为用，必须有九阴白骨爪这样的大招才能制胜，需要重新实现父类方法
 */
public class Test {
    public static void main(String[] args) {
        //需求: 调用NineYin类中的功能
        NineYin ny = new NineYin();
        ny.internalStrength();
        ny.stroke();
    }
}
</code></pre>
<pre><code class="language-java">/*
    父类, 武功类
    四大权限修饰符的修饰范围从小到大分别是:
        private, 默认(什么都不写就是默认), protected, public
 */
public class Martial {
    //练习内功
    public void internalStrength() {
        System.out.println(&quot;练习内功&quot;);
    }
    //练习招式
    public void stroke() {
        System.out.println(&quot;练习招式&quot;);
    }
}
</code></pre>
<pre><code class="language-java">//子类: 九阴真经.
public class NineYin extends Martial {
    //练习内功
    @Override
    public void internalStrength() {
        //这里是在调用父类的成员方法.
        super.internalStrength();

        System.out.println(&quot;以柔克刚&quot;);
    }
    //练习招式
    @Override
    public void stroke() {
        System.out.println(&quot;九阴白骨爪&quot;);
    }
}
</code></pre>
<h3 id="继承关系中构造方法的使用">继承关系中构造方法的使用</h3>
<pre><code class="language-java">/*
    测试类, 用来演示: 构造方法的调用的
    结论:
        子类所有构造方法的第一行都有一个默认的super()用来访问父类的无参构造方法.
        如果父类没有无参构造, 可以通过super(参数)的形式访问父类的带参构造.
 */
public class Test {
    public static void main(String[] args) {
        //创建子类对象
        Worker w = new Worker();
    }
}
</code></pre>
<pre><code class="language-java">//父类
public class Person {
    public Person(String name) {
        //System.out.println(&quot;Person类的 空参构造&quot;);
        System.out.println(&quot;Person类的带参构造 &quot; + name);
    }
}
</code></pre>
<pre><code class="language-java">//子类
public class Worker extends  Person {
    public Worker() {
        //super();    //用于初始化父类成员的.
        super(&quot;小黑&quot;);
        System.out.println(&quot;Worker类的 空参构造&quot;);
    }
}
</code></pre>
<h2 id="方法重写override">方法重写(Override)</h2>
<ul>
<li>定义：
<ul>
<li>子类中出现和父类方法定义相同的方法的现象</li>
</ul>
</li>
<li>解释：
<ul>
<li>方法重写也叫方法的复写、覆盖</li>
<li>方法名、参数列表、返回值类型都相同</li>
</ul>
</li>
<li>注意事项：
<ul>
<li>父类私有方法无法重写</li>
<li>之类方法访问权限不能小于父类方法</li>
<li>之类不能比父类方法抛出更大的异常</li>
</ul>
</li>
<li>使用场景：
<ul>
<li>扩展父类功能</li>
<li>父类功能过时，重新实现父类功能</li>
</ul>
</li>
</ul>
<h2 id="java中的访问权限修饰符">Java中的访问权限修饰符</h2>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">本类</th>
<th style="text-align:center">本包</th>
<th style="text-align:center">子类</th>
<th style="text-align:center">其他类</th>
</tr>
</thead>
<tbody>
<tr>
<td>private</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>默认</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>protected</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>public</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
</tbody>
</table>
<h2 id="方法重载与方法重写的区别">方法重载与方法重写的区别</h2>
<table>
<thead>
<tr>
<th></th>
<th>重载</th>
<th>重写</th>
</tr>
</thead>
<tbody>
<tr>
<td>方法名</td>
<td>相同</td>
<td>相同</td>
</tr>
<tr>
<td>参数列表</td>
<td>不同</td>
<td>相同</td>
</tr>
<tr>
<td>返回值类型</td>
<td>无关</td>
<td>相同</td>
</tr>
<tr>
<td>修饰符</td>
<td>无关</td>
<td>访问权限不小于被重写方法</td>
</tr>
<tr>
<td>定义位置</td>
<td>同一个类</td>
<td>子父类中</td>
</tr>
</tbody>
</table>
<h2 id="多态">多态</h2>
<h3 id="演示多态">演示多态</h3>
<pre><code class="language-java">/*
     动物类案例:
         已知父类Animal, 成员变量为: 姓名, 成员方法为: eat()方法.
         其有一子类Dog类, 请用该案例模拟多态.
  */
public class Test {
    public static void main(String[] args) {
        //需求: 演示多态
        /*
            Java中实现多态的三个步骤:
                1. 要有继承(或者实现)关系.
                2. 要有方法重写.
                3. 要有父类引用指向子类对象.
         */
        //多态
        Animal an = new Dog();

        //测试成员方法的调用
        //结论: 多态中调用成员方法是编译看左(左边的类型有没有这个成员),
        //     运行看右(运行时具体用的是右边类中的该成员).
        an.setName(&quot;哈士奇&quot;);
        an.eat();
    }
}
</code></pre>
<pre><code class="language-java">//定义父类
public class Animal {
    //姓名
    private String name;

    //空参构造
    public Animal() {
    }

    //全参构造
    public Animal(String name) {
        this.name = name;
    }

    //getXxx(), setXxx()

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    //成员方法
    public void eat() {
        System.out.println(&quot;吃饭&quot;);
    }
}
</code></pre>
<pre><code class="language-java">//是Animal类的子类
public class Dog extends  Animal{
    //需求: 因为狗吃骨头, 所以要优化父类的eat()方法
    @Override
    public void eat() {
        System.out.println(getName() + &quot;吃骨头&quot;);
    }
}
</code></pre>
<h3 id="使用场景">使用场景</h3>
<pre><code class="language-java">/*
     已知父类Animal, 成员变量为: 姓名, 成员方法为: eat()方法.
     它有两个子类Dog类, Mouse类, 两个子类都重写了Animal类中的eat()方法.
     在测试类中, 定义showAnimal()方法, 用来测试Dog类和Mouse类.
 */
public class Test {
    public static void main(String[] args) {
        //用来测试Dog类和Mouse类.
        //测试Dog类
        Dog d = new Dog();
        d.setName(&quot;哈士奇&quot;);
        showAnimal(d);

        //测试老鼠类
        Mouse m = new Mouse();
        m.setName(&quot;Jerry&quot;);
        showAnimal(m);


    }
    //需求: 在该类中定义showAnimal()方法
    //多态的做法
    //多态的使用场景: 父类型可以作为形参的数据类型,
    //这样可以接收其任意的子类对象.
    public static void showAnimal(Animal an) {
        an.eat();
    }

    //传统做法
    /*public static void showAnimal(Dog d) {
        d.eat();
    }

    public static void showAnimal(Mouse m) {
        m.eat();
    }*/
}
</code></pre>
<pre><code class="language-java">//父类, 动物类
public class Animal {
    //成员变量
    private String name;

    //构造方法
    public Animal() {
    }

    public Animal(String name) {
        this.name = name;
    }

    //getXxx(), setXxx()

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    //成员方法
    //吃饭
    public void eat() {
        System.out.println(&quot;吃饭&quot;);
    }
}
</code></pre>
<pre><code class="language-java">//子类, 狗类.
public class Dog extends Animal {
    @Override
    public void eat() {
        System.out.println(getName() + &quot;吃骨头&quot;);
    }
}
</code></pre>
<pre><code class="language-java">//子类, 老鼠类
public class Mouse extends Animal {
    @Override
    public void eat() {
        System.out.println(getName() + &quot;吃奶酪&quot;);
    }
}
</code></pre>
<h3 id="测试多态关系中成员变量的使用">测试多态关系中，成员变量的使用</h3>
<pre><code class="language-java">/*
    需求: 测试多态关系中, 成员变量的使用.

    结论:
        多态关系中, 成员变量是不涉及到重写的.
        简单记忆:
            多态关系中, 使用成员变量, 遵循&quot;编译看左, 运行看左&quot;.
                编译看左: 意思是在编译期间会看左边的类型有没有这个成员, 没有就报错, 有就不报错.
                运行看左: 意思是在运行期间使用的是 左边的类型中的这个成员.
 */
public class Test {
    public static void main(String[] args) {
        //通过多态的方式创建对象, 然后测试成员变量的使用.
        //多态: 父类引用指向子类对象
        Animal an = new Dog();
        System.out.println(an.name);

        //通过普通方式创建对象, 然后测试
        Dog dog = new Dog();
        System.out.println(dog.name);
    }
}
</code></pre>
<pre><code class="language-java">//父类, 动物类
public class Animal {
    String name = &quot;Animal&quot;;
}
</code></pre>
<pre><code class="language-java">//子类, 狗类
public class Dog extends Animal{
    String name = &quot;Dog&quot;;
}
</code></pre>
<h3 id="多态的好处与弊端-类型转换">多态的好处与弊端 类型转换</h3>
<pre><code class="language-java">/*
   需求:
        多态的好处:
            可维护性.
            可扩展性.
        多态的弊端:
            父类引用不能使用子类的特有成员.

            解决方案:
                通过&quot;类型转换&quot;实现.
            注意:
                只能在继承层次内进行转换, 否则会报ClassCastException异常
                将父类对象转换成子类之前，使用instanceof进行检查
                instanceof关键字的用法:
                    对象名 instanceof 数据类型
                   意思是判断前边的对象是否是后边的数据类型.
 */
public class Test {
    public static void main(String[] args) {
        //需求: 通过多态创建对象, 调用子类中的成员.
        Animal an = new Dog();

        //调用eat()方法
        an.eat();

        //调用watch()方法, 属于子类独有的方法.
        //an.watch();
        //正确的写法
        /*Dog dog = (Dog)an;
        dog.watch();*/

        //不正常的转换.
        //Cat c = (Cat)an;

        //优化后的方案: 判断当前对象是否是Dog类的对象, 如果是, 再调用watch()方法.
        if(an instanceof Dog) { //判断an是否是Dog类的对象
            //能走到这里, 说明条件满足
            Dog dog = (Dog)an;
            dog.watch();
        }
    }
}
</code></pre>
<pre><code class="language-java">//父类, 动物类
public class Animal {
    public void eat() {
        System.out.println(&quot;吃饭&quot;);
    }
}
</code></pre>
<pre><code class="language-java">//子类, 狗类
public class Dog extends Animal {
    @Override
    public void eat() {
        System.out.println(&quot;狗吃骨头&quot;);
    }

    //狗类独有的方法, 父类中是没有这个成员方法的.
    public void watch() {
        System.out.println(&quot;狗会看家&quot;);
    }
}
</code></pre>
<pre><code class="language-java">//子类, 猫类.
public class Cat extends Animal {
}
</code></pre>
<h2 id="抽象类">抽象类</h2>
<pre><code class="language-java">
/*
    抽象类解释:
        有抽象方法的类就是抽象类, 用abstract关键字修饰.

    抽象方法解释:
        没有方法体的方法就是抽象方法, 用abstract关键字修饰.

    抽象方法的由来:
        当需要定义一个方法，却不明确方法的具体实现时，可以将方法定义为abstract，具体实现延迟到子类

 */

public class Test {
    public static void main(String[] args) {
        //测试狗类
        Dog dog = new Dog();
        dog.eat();
        //测试老鼠类
        Mouse mouse = new Mouse();
        mouse.eat();
        System.out.println(&quot;-------------------&quot;);
        //通过多态进行测试.
        Animal an = new Dog();
        an.eat();


    }
}
</code></pre>
<pre><code class="language-java">//父类, 动物类(抽象类)
public abstract class Animal {
    //抽象方法(特点: 要求子类必须重写)
    public abstract void eat() ;
}
</code></pre>
<pre><code class="language-java">//子类, 狗类
public class Dog extends Animal {
    //alt + enter: 快捷键, 自动帮你重写方法
    @Override
    public void eat() {
        System.out.println(&quot;狗吃骨头&quot;);
    }
}
</code></pre>
<pre><code class="language-java">//子类, 老鼠类
public class Mouse extends Animal {
    @Override
    public void eat() {
        System.out.println(&quot;老鼠吃奶酪&quot;);
    }
}
</code></pre>
<h3 id="抽象类的特点">抽象类的特点</h3>
<pre><code class="language-java">/*
    抽象类的特点:
        1. 抽象类和抽象方法必须用abstract关键字修饰.
        2. 抽象方法不能实例化.
           那抽象类怎么实例化呢?
           答: 通过创建其子类对象来完成初始化操作.
       3. 抽象类的子类:
            如果是普通类, 则必须重写所有的抽象方法.
            如果是抽象类, 则不用重写抽象方法.

   抽象类的成员特点:
      1. 可以有普通的成员变量, 也可以有成员常量.
      2. 可以有抽象方法, 也可以有非抽象方法.
      3. 有构造方法, 并且构造方法还可以重载.

      总结:
        抽象类中的成员比普通类多一种: 抽象方法.
        其他和普通类一样.
 */
public class Test {
    public static void main(String[] args) {
        //抽象类不能new(抽象类不能实例化)
        //Animal an = new Animal();  这样写是错误的.

        //初始化抽象类
        Animal an = new Cat();
        System.out.println(&quot;------------------------&quot;);

        //抽象类的成员特点
        an.name = &quot;汤姆&quot;;
        System.out.println(an.name);

        //an.AGE = 50; 代码会报错, 原因是因为常量的值不能发生改变.
        System.out.println(an.AGE);
    }
}
</code></pre>
<pre><code class="language-java">//父类, 动物类(抽象类)
public abstract class Animal {
    //构造方法
    public Animal() {}

    public Animal(String name){
        this.name = name;
    }

    //成员变量: 其值可以变化
    String name = &quot;哈士奇&quot;;
    //成员常量: 其值不能发生改变
    final int AGE = 30;

    //吃
    public abstract void eat();

    //睡
    public abstract void sleep();

    public void call() {
        System.out.println(&quot;动物会叫&quot;);
    }
}
</code></pre>
<pre><code class="language-java">//子类, 猫类
public class Cat extends Animal {
    @Override
    public void eat() {
        System.out.println(&quot;猫吃鱼&quot;);
    }

    @Override
    public void sleep() {
        System.out.println(&quot;猫躺着睡&quot;);
    }
}
</code></pre>
<pre><code class="language-java">//子类, 狗类
public abstract class Dog extends Animal {
}
</code></pre>
<h3 id="抽象类的构造方法">抽象类的构造方法</h3>
<pre><code class="language-java">/*
    需求：
        开发团队中有程序员和经理两种角色，他们都有姓名、工资、工号等属性，都有工作的行为，
        经理还有奖金属性。请使用继承思想设计出上述需求中的类，并分别创建对象使用。
    父类Employee
	    name，salary，id；work();
	程序员类Coder，继承Employee，属性和行为：
	    work();
    经理类Manager，继承Employee，属性和行为：
	    bonus; work();
 */
public class Test {
    public static void main(String[] args) {
        //测试程序猿类
        Employee em = new Coder();
        em.work();

        //测试经理类
        Employee em2 = new Manager();
        em2.work();
        System.out.println(&quot;------------------&quot;);

        //扩展内容, 快速实例化对象
        //需求: 创建一个姓名叫张三, 工资为30000, 工号为: 研发部007的程序猿.
       /* Coder c = new Coder();
        c.setName(&quot;张三&quot;);
        c.setSalary(30000);
        c.setId(&quot;研发部007&quot;);*/
       Coder c = new Coder(&quot;张三&quot;,30000,&quot;研发部07&quot;);
        System.out.println(&quot;姓名: &quot; + c.getName());
        System.out.println(&quot;工资: &quot; + c.getSalary());
        System.out.println(&quot;工号: &quot; + c.getId());
        System.out.println(&quot;----------------------&quot;);

        //需求: 创建一个名字叫: 李四, 工资为: 40000, 工号为: 研发部01, 奖金为100000 的经理
        Manager m = new Manager(&quot;李四&quot;,40000,&quot;研发部01&quot;,100000);
        System.out.println(&quot;姓名: &quot; + m.getName());
        System.out.println(&quot;工资: &quot; + m.getSalary());
        System.out.println(&quot;工号: &quot; + m.getId());
        System.out.println(&quot;奖金: &quot; + m.getBonus());
    }
}
</code></pre>
<pre><code class="language-java">//父类, 员工类
public abstract class Employee {
    //成员变量
    //姓名
    private String name;
    //工资
    private double salary;
    //工号
    private String id;

    //构造方法
    public Employee() {
    }

    public Employee(String name, double salary, String id) {
        this.name = name;
        this.salary = salary;
        this.id = id;
    }

    //getXxx(), setXxx()

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getSalary() {
        return salary;
    }

    public void setSalary(double salary) {
        this.salary = salary;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    //成员方法
    //工作
    public abstract void work();
}
</code></pre>
<pre><code class="language-java">//子类, 程序猿类
public class Coder extends Employee {
    //小细节: 在实际开发中, 子类一般都有两个构造方法.
    //子类的空参构造访问父类的空参构造.
    //子类的全参构造访问父类的全参构造
    public Coder() {
        super();
    }

    public Coder(String name, double salary, String id) {
        super(name, salary, id);
    }

    @Override
    public void work() {
        System.out.println(&quot;程序猿要敲代码&quot;);
    }
}
</code></pre>
<pre><code class="language-java">//子类, 经理类
public class Manager extends Employee {
    public Manager() {
       
    }

    public Manager(String name, double salary, String id, int bonus) {
        super(name, salary, id);
        this.bonus = bonus;
    }

    //奖金
    private int bonus;

    public int getBonus() {
        return bonus;
    }

    public void setBonus(int bonus) {
        this.bonus = bonus;
    }

    @Override
    public void work() {
        System.out.println(&quot;经理喝着茶翘着二郎腿看着程序猿写代码&quot;);
    }
}
</code></pre>
<h2 id="final关键字">final关键字</h2>
<pre><code class="language-java">/*
    final关键字:
        final这个单词是&quot;最终&quot;的意思, 在Java中是一个关键字, 可以用来修饰类, 成员变量, 成员方法.
        修饰的类:   不能被继承, 但是可以继承其他的类.
        修饰的方法: 不能被重写.
        修饰的变量: 是一个常量, 值只能设置一次.

 */
public class Test {
    public static void main(String[] args) {
        Employee em = new Coder();
        em.show();
        System.out.println(&quot;------------------------&quot;);

        //final修饰的变量:  基本类型的变量, 是值不能改变.
        final int NUM = 20;
        //NUM = 30;  代码报错, 常量值只能设置一次.
        System.out.println(NUM);
        System.out.println(&quot;------------------------&quot;);
        //final修饰的变量:  引用类型的变量, 是地址值不能改变,但是属性值可以发生变化.
        final Employee em2 = new Employee();
        //em2 = new Employee();  代码报错, 原因是因为只要new就会开辟新空间.
        em2.name = &quot;张三&quot;;
        em2.age = 23;
        System.out.println(&quot;name属性值: &quot; + em2.name);
        System.out.println(&quot;age属性值: &quot; + em2.age);
        System.out.println(&quot;-----------------------------&quot;);

        em2.name = &quot;张无忌&quot;;
        em2.age = 53;
        System.out.println(&quot;name属性值: &quot; + em2.name);
        System.out.println(&quot;age属性值: &quot; + em2.age);
    }
}
</code></pre>
<pre><code class="language-java">//人类
public class Person {
}
</code></pre>
<pre><code class="language-java">//员工类
public class Employee/* extends Person*/ {
    //成员变量
    String name;
    int age;

    public final void show() {
        System.out.println(&quot;这个是绝密文件&quot;);
    }
}
</code></pre>
<pre><code class="language-java">//程序员类
public class Coder extends Employee{
   /* @Override
    public void show() {
        System.out.println(&quot;这个是垃圾文件&quot;);
    }*/
}
</code></pre>
<h2 id="static关键字">static关键字</h2>
<pre><code class="language-java">/*
    static关键字:
        该单词是&quot;静态&quot;的意思, 可以用来修饰成员变量和成员方法.
        关于static修饰的成员变量:
            该变量叫静态变量(类变量), 静态变量被该类下所有的对象所共享.
        静态成员的调用方式:
            可以通过 类名. 的形式直接调用.
    需求: 定义研发部成员类，让每位成员进行自我介绍
        Developer类:
            成员变量: 姓名name, 工作内容work, 部门名字departmentName
            成员方法: 进行自我介绍的方法selfIntroduction();
 */
public class Test {
    public static void main(String[] args) {
        //需求: 创建两个员工, 然后测试
        Developer d1 = new Developer();
        d1.name = &quot;小黑&quot;;
        d1.work = &quot;写代码&quot;;
        d1.selfIntroduction();

        Developer d2 = new Developer();
        d2.name = &quot;媛媛&quot;;
        d2.work = &quot;鼓励师&quot;;
        d2.selfIntroduction();
        System.out.println(&quot;---------------------&quot;);
        //随着公司的发展, 部门名字要进行调整, 改为: 开发部
        //Developer.departmentName = &quot;开发部&quot;;

        d1.selfIntroduction();
        d2.selfIntroduction();
    }
}
</code></pre>
<pre><code class="language-java">//开发者类
public class Developer {
    //成员变量
    //姓名
    String name;
    //工作内容
    String work;
    //部门名(公共的静态常量)
    public final static String DEPARTMENT_NAME = &quot;研发部&quot;;      //应该用static修饰

    //成员方法
    //自我介绍
    public void selfIntroduction() {
        System.out.println(&quot;我是&quot;+ DEPARTMENT_NAME +&quot;的&quot;+ name +&quot;, 我的工作内容是&quot; + work);
    }
}
</code></pre>
<h3 id="static修饰成员方法">static修饰成员方法</h3>
<pre><code class="language-java">/*
    static修饰成员方法
    静态方法：
        静态方法中没有对象this，所以不能访问非静态成员
    静态方法的使用场景
        如果某方法只访问静态成员, 并且不需要通过 对象名. 的形式调用, 就可以考虑将其定义为: 静态方法.

    需求：定义静态方法，反转数组中的元素
        核心:
            1. 其实就是arr[i]  和 arr[arr.length - 1 - i] 在交换.
            2. 循环次数只需要执行数组长度的一般就可以了, 也就是: arr.length/2
  */
public class Test {
    public static void main(String[] args) {
        //测试show()方法
        ReverseArray.show();

        //小需求: 交换变量.
        int a = 10;
        int b = 20;
        int temp = a;   //temp=10, a=10, b=20
        a = b;          //temp=10, a=20, b=20
        b = temp;       //temp=10, a=20, b=10
        System.out.println(&quot;a: &quot; + a);
        System.out.println(&quot;b: &quot; + b);

        System.out.println(&quot;-------------------------&quot;);
        int[] arr = {1, 6, 4, 5, 2, 3};
        for (int i = 0; i &lt;arr.length; i++) {
            System.out.println(arr[i]);
        }
        System.out.println(&quot;-------------------------&quot;);

        //调用方法, 反转数组
        ReverseArray.reverse(arr);
        for (int i = 0; i &lt;arr.length; i++) {
            System.out.println(arr[i]);
        }

    }
}
</code></pre>
<pre><code class="language-java">public class ReverseArray {
    int num1 = 10;
    static int num2 = 20;

    //静态方法中没有对象this，所以不能访问非静态成员
    public static void show() {
        //System.out.println(num1);
        System.out.println(num2);
    }


    //需求：定义静态方法，反转数组中的元素
    public static void reverse(int[] arr) {
        /*
            这里只需要完成: 交换元素的动作就可以了.
            假设数组中的元素值为: int[] arr = {11, 22, 33, 44, 55};
            明确谁和谁进行交换:
                第一个元素11   和  最后一个元素55 交换
                第二个元素22   和  倒数第二个元素44 交换
                ...
                arr[i]             arr[arr.length - 1 - i]

            明确交换次数:
                数组的长度/2
         */
        for (int i = 0; i &lt; arr.length / 2 ; i++) {
            // arr[i] 和 arr[arr.length - 1 - i]进行交换
            int temp = arr[i];
            arr[i] = arr[arr.length - 1 - i];
            arr[arr.length - 1 - i] = temp;
        }
    }
}
</code></pre>
<h2 id="接口">接口</h2>
<pre><code class="language-java】">/*接口：
    就是提供的统一规则，规范。
    定义格式：
        interface 接口名{}
        类和接口之间是实现关系，用关键字implements来表示
        class 类名 implements 接口名{}
 */
public class Test {
    public static void main(String[] args) {
    //多态
        Smoking sm = new Teacher();
        sm.smoke();
    }
}
</code></pre>
<pre><code class="language-java">//接口，表示抽烟的功能
public interface Smoking {
    //成员方法
    public abstract void smoke();
}
</code></pre>
<pre><code class="language-java">//接口Smoking的实现类（子类）
public class Teacher implements Smoking{

    @Override
    public void smoke() {
        System.out.println(&quot;抽烟有害健康&quot;);
    }
}
</code></pre>
<h3 id="特点">特点</h3>
<ul>
<li>
<p>普通类</p>
<pre><code class="language-java">/*
    接口创建对象的特点：
        1. 接口不能实例化，需要创建其之类对象来完成实例化操作
        2. 接口的之类，
            如果是普通类，则必须重写接口中的所有抽象方法。
            如果是抽象类，则不用重写接口中的抽象方法。
        接口和类之间的关系：
            类与类之间：
                继承关系，只能单继承，不能多继承，但是可以多层继承
            类与接口之间：
                实现关系，可以单实现，也可以多实现
            接口与接口之间：
                继承关系，可以单继承，也可以多继承
        总结：
            对于一个类来讲，它的父类(继承的关系)中定义的都是：共性内容
            对于一个类来讲，它的父接口(实现的关系)中定义的都是：扩展内容
 */
public class Test {
    public static void main(String[] args) {
    //测试鼠标类
        USB usb = new Mouse();
        usb.open();
        usb.close();
    }
}
</code></pre>
<pre><code class="language-java">//接口， USB接口
public interface USB {
    //连接
    public abstract void open();
  
    //断开
    public abstract void close();
}
</code></pre>
<pre><code class="language-java">//子类，鼠标类
public class Mouse implements USB{
    @Override
    public void open() {
        System.out.println(&quot;连接鼠标&quot;);
    }
  
    @Override
    public void close() {
        System.out.println(&quot;断开鼠标连接&quot;);
    }
}
</code></pre>
</li>
<li>
<p>抽象类</p>
<pre><code class="language-java">//之类，键盘类
public abstract class KeyBoard implements USB{
}
</code></pre>
</li>
<li>
<p>多实现</p>
<pre><code class="language-java">//子类，鼠标类
public class Mouse implements USB,A,B{
    @Override
    public void open() {
        System.out.println(&quot;连接鼠标&quot;);
    }
  
    @Override
    public void close() {
        System.out.println(&quot;断开鼠标连接&quot;);
    }
}
</code></pre>
</li>
<li>
<p>多继承</p>
<pre><code class="language-java">public interface C extends A,B,USB{
}
</code></pre>
</li>
<li>
<p>成员变量和成员方法</p>
<pre><code class="language-java">/*
    接口中的成员特点：
        成员变量：
            接口中只有成员常量，没有成员变量
            原因是因为接口中所有的变量都有默认修饰符: public static final
        成员方法：
            JDK7及以前，只能定义抽象方法，
            原因是所有方法都有默认修饰符： public abstract
  
            JDK8以后，可以有带方法体的方法了。
            静态方法直接写，非静态方法要用default修饰
  
            JDK9以后，可以有私有方法了，直接写即可，
        构造方法：
            接口中没有构造方法。
 */
public class Test {
    public static void main(String[] args) {
        //测试接口中的成员常量
        //USB.NUM = 20 ;    //这样写代码会报错，常量的值不能修改
        System.out.println(USB.NUM);
    }
}
</code></pre>
<pre><code class="language-java">public interface USB {
    //成员常量
    public static final int NUM = 10;
  
    //成员方法
    //JDK7及其以前的写法
    public abstract void open();
    public abstract void close();
  
    //JDK8多了两种写法
    public static void method1(){
        System.out.println(&quot;我是JDK8的新特性&quot;);
    }
    public default void method2(){
        System.out.println(&quot;我是JDK8的新特性&quot;);
    }
  
    //JDK9多了一种写法
    private void method3(){
        System.out.println(&quot;我是JDK9的新特性&quot;);
    }
}
</code></pre>
</li>
</ul>
        </div>
        
        
        
        
        
        
        
<div class="flex flex-col md:flex-row md:justify-between -mx-2 mt-4 px-2 pt-4 border-t">
    <div>
        
        <span class="block font-bold">Previous</span>
        <a href="https://liu-moon.github.io/posts/%E5%B0%8F%E7%8B%BC%E6%AF%AB/" class="block">小狼毫</a>
        
    </div>
    <div class="md:text-right mt-4 md:mt-0">
        
        <span class="block font-bold">Next</span>
        <a href="https://liu-moon.github.io/posts/ad/" class="block">AD</a>
        
    </div>
</div>

        
    </div>
    
    <div class="col-span-2">
        
        
        <div class="sticky top-16 z-10 hidden lg:block px-6 py-4  bg-primary-bg ">
    <span class="text-lg font-semibold">On This Page</span>
</div>
<div class="sticky-toc hidden lg:block px-6 pb-6 ">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#idea常用快捷键">idea常用快捷键</a></li>
    <li><a href="#方法重载overload">方法重载(Overload)</a></li>
    <li><a href="#scanner的基本使用">Scanner的基本使用</a>
      <ul>
        <li><a href="#scanner的步骤">Scanner的步骤</a></li>
      </ul>
    </li>
    <li><a href="#break标号">break标号</a></li>
    <li><a href="#random类">Random类</a>
      <ul>
        <li><a href="#random类的使用">Random类的使用</a></li>
        <li><a href="#案例-猜数字的小游戏">案例: 猜数字的小游戏</a></li>
      </ul>
    </li>
    <li><a href="#抽象">抽象</a>
      <ul>
        <li><a href="#手机类">手机类</a></li>
      </ul>
    </li>
    <li><a href="#privatethis">private&amp;this</a></li>
    <li><a href="#构造方法">构造方法</a></li>
    <li><a href="#javabean类">JavaBean类</a></li>
    <li><a href="#继承">继承</a>
      <ul>
        <li><a href="#super">super</a></li>
        <li><a href="#继承关系中成员方法的使用">继承关系中成员方法的使用</a></li>
        <li><a href="#继承关系中构造方法的使用">继承关系中构造方法的使用</a></li>
      </ul>
    </li>
    <li><a href="#方法重写override">方法重写(Override)</a></li>
    <li><a href="#java中的访问权限修饰符">Java中的访问权限修饰符</a></li>
    <li><a href="#方法重载与方法重写的区别">方法重载与方法重写的区别</a></li>
    <li><a href="#多态">多态</a>
      <ul>
        <li><a href="#演示多态">演示多态</a></li>
        <li><a href="#使用场景">使用场景</a></li>
        <li><a href="#测试多态关系中成员变量的使用">测试多态关系中，成员变量的使用</a></li>
        <li><a href="#多态的好处与弊端-类型转换">多态的好处与弊端 类型转换</a></li>
      </ul>
    </li>
    <li><a href="#抽象类">抽象类</a>
      <ul>
        <li><a href="#抽象类的特点">抽象类的特点</a></li>
        <li><a href="#抽象类的构造方法">抽象类的构造方法</a></li>
      </ul>
    </li>
    <li><a href="#final关键字">final关键字</a></li>
    <li><a href="#static关键字">static关键字</a>
      <ul>
        <li><a href="#static修饰成员方法">static修饰成员方法</a></li>
      </ul>
    </li>
    <li><a href="#接口">接口</a>
      <ul>
        <li><a href="#特点">特点</a></li>
      </ul>
    </li>
  </ul>
</nav>
</div>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        enableStickyToc();
    });
</script>
        
    </div>
    

    
    
</div>
<script>
    document.addEventListener('DOMContentLoaded', ()=>{
        hljs.initHighlightingOnLoad();
    })
</script>

      </div>
    </div>
    
  </main>
  <footer class="pl-scrollbar">
    <div class="w-full max-w-screen-xl mx-auto"><div class="text-center p-6 pin-b">
    <p class="text-sm text-tertiary-text">&copy; 2021 <a href="https://www.wangchucheng.com/">C. Wang</a> and <a href="https://www.ruiqima.com/">R. Ma</a>
 &middot;  Powered by the <a href="https://github.com/wangchucheng/hugo-eureka" class="hover:text-eureka">Eureka</a> theme for <a href="https://gohugo.io" class="hover:text-eureka">Hugo</a></p>
</div></div>
  </footer>
</body>

</html>